---
title: DifferentialEquations.jl Workshop Exercises
author: Chris Rackauckas
---

These excersies teach common workflows which involve DifferentialEquations.jl.
The designation (B) is for "Beginner", meaning that a user new to the package
should feel comfortable trying this exercise. An exercise designated (I) is
for "Intermediate", meaning the user may want to have some previous background
in DifferentialEquations.jl or try some (B) exercises first. The additional
(E) designation is for "Experienced", which are portions of exercises which may
take some work.

The exercises are described as follows:

- Exercise 1 takes the user through defining the same biological system with
  stochasticity, utilizing EnsembleProblems to understand 95%
  bounds on the solution, and perform Bayesian parameter estimation.
- Exercise 2 takes the user through defining hybrid differential equation,
  that is a differential equation with events, and using adjoints to
  to perform gradient-based parameter estimation.
- Exercise 3 takes the user through differential-algebraic equation (DAE)
  modeling, the concept of index, and using both mass-matrix and implicit
  ODE representations.
- Exercise 4 takes the user through optimizing a PDE solver, utilizing
  automatic sparsity pattern recognition, automatic conversion of numerical
  codes to symbolic codes for analytical construction of the Jacobian,
  preconditioned GMRES, and setting up a solver for IMEX and GPUs.
- Exercise 5 focuses on a parameter sensitivity study, utilizing GPU-based
  ensemble solvers to quickly train a surrogate model to perform global
  parameter optimization.
- Exercise 6 takes the user through training a neural stochastic differential
  equation, using GPU-accleration and adjoints through Flux.jl's neural
  network framework to build efficient training codes.

## (B) Investigating Sources of Randomness and Uncertainty in a Biological System

### Part 1: Simulating a deterministic chemical reaction system

### Part 2: Adding stochasticity with stochastic differential equations

### Part 3: Gillespie jump models of discrete stochasticity

### Part 4: Using DiffEqBiological's Reaction Network DSL

### (I) Part 5: Bayesian Parameter Estimation with DiffEqBayes.jl + Turing.jl

## (B) Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses

### Part 1: Defining an ODE with Predetermined Doses

### Part 2: Adding Delays

### Part 3: Utilizing Adjoints and Automatic Differentiation (AD) for Optimization

### Part 4: Fitting Known Quantities with DiffEqParamEstim.jl + Optim.jl

### (I) Part 5: Implementing Control-Based Logic with ContinuousCallbacks

## (B) Differential-Algebraic Equation Modeling of a Double Pendulum

Differential-Algebraic Equaton (DAE) systems are like ODEs but allow for adding
constraints into the models. This problem will look at solving the double
penulum problem with enforcement of the rigid body constraints, requiring that
the total distance `L` is constant throughout the simulation. While these
equations can be rewritten in an ODE form, in many cases it can be simpler
to solve the equation directly with the constraints. This tutorial will
cover both the idea of index, how to manually perform index reduction,
and how to make use of mass matrix and implicit ODE solvers to handle these
problems.

### Part 1: Simple Introduction to DAEs: Mass-Matrix Robertson Equations

### Part 2: Solving the Implicit Robertson Equations with IDA

### Part 3: Manual Index Reduction of the Double Pendulum

### Part 4: Double Pendulum Solution with IDA

## (I) Performance Optimizing and Parallelizing Semilinear PDE Solvers

This problem will focus on implementing and optimizing the solution of the
2-dimensional Brusselator equations. The BRUSS equations are a well-known
highly stiff oscillatory system of partial differential equations which are
used in stiff ODE solver benchmarks. In this tutorial we will walk first
through a simple implmentation, then do allocation-free implementations and
looking deep into solver options and benchmarking.

### Part 1: Implementing the BRUSS PDE System as ODEs

The Brusselator PDE is defined as follows:

$$\begin{align}
\frac{\partial u}{\partial t} &= 1 + u^2v - 4.4u + \alpha(\frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2}) + f(x, y, t)
\frac{\partial v}{\partial t} &= 3.4u - u^2v + \alpha(\frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2})
\end{align}$$

where

$$f(x, y, t) = \begin{cases}
5 & \quad \text{if } (x-0.3)^2+(y-0.6)^2 ≤ 0.1^2 \text{ and } t ≥ 1.1 \\
0 & \quad \text{else}
\end{cases}$$

and the initial conditions are

$$\begin{align}
u(x, y, 0) &= 22\cdot y(1-y)^{3/2} \\
v(x, y, 0) &= 27\cdot x(1-x)^{3/2}
\end{align}$$

with the periodic boundary condition

$$\begin{align}
u(x+1,y,t) &= u(x,y,t) \\
u(x,y+1,t) &= u(x,y,t)
\end{align}$$

on a timespan of $t \in [0,22]$.

To solve this PDE, we will discretize it into a system of ODEs with the finite
difference method. We discretize `u` and `v` into arrays of the values at each
time point: `u[i,j] = u(i*dx,j*dy)` for some choice of `dx`/`dy`, and same for
`v`. Then our ODE is defined with `U[i,j,k] = [u v]`. The second derivative
operator, the Laplacian, discretizes to become the `Tridiagonal` matrix with
`[1 -2 1]` and a `1` in the top left and right corners. The nonlinear functions
are then applied at each point in space (they are broadcast). Use `dx=dy=1/32`.

You will know when you have the correct solution when you plot the solution
at `x=0.25` and see a periodic orbit.

If you are not familiar with this process, see
[the Gierer-Meinhardt example from the DiffEqTutorials.](http://juliadiffeq.org/DiffEqTutorials.jl/html/introduction/03-optimizing_diffeq_code.html)

Note: Start by doing the simplest implementation!

### Part 2: Optimizing the BRUSS Code

PDEs are expensive to solve, and so we will go nowhere without some code
optimizing! Follow the steps described in the
[the Gierer-Meinhardt example from the DiffEqTutorials](http://juliadiffeq.org/DiffEqTutorials.jl/html/introduction/03-optimizing_diffeq_code.html)
to optimize your Brusselator code. Try other formulations and see what ends
up the fastest! Find a trade-off between performance and simplicity that suits
your needs.

### Part 3: Exploiting Jacobian Sparsity with Color Differentiation

Use the `sparsity!` function from [SparseDiffTools](https://github.com/JuliaDiffEq/SparseDiffTools.jl)
to generate the sparsity pattern for the Jacobian of this problem. Follow
the documentations [on the DiffEqFunction page](http://docs.juliadiffeq.org/latest/features/performance_overloads.html)
to specify the sparsity pattern of the Jacobian. Generate an add the color
vector to speed up the computation of the Jacobian.

### (Optional) Part 4: Structured Jacobians

Specify the sparsity pattern using a BlockBandedMatrix from
[BlockBandedMatrices.jl](https://github.com/JuliaMatrices/BlockBandedMatrices.jl)
to accelerate the previous sparsity handling tricks.

### (Optional) Part 5: Automatic Symbolicification and Analytical Jacobian

Use the `modelingtoolkitize` function from ModelingToolkit.jl to convert your
numerical ODE function into a symbolic ODE function and use that to compute and
solve with an analytical sparse Jacobian.

### Part 6: Utilizing Preconditioned-GMRES Linear Solvers

Use the [linear solver specification page](http://docs.juliadiffeq.org/latest/features/linear_nonlinear.html)
to solve the equation with `TRBDF2` with GMRES. Use the Sundials documentation
to solve the equation with `CVODE_BDF` with Sundials' special internal GMRES.
To both of these, use the [AlgebraicMultigrid.jl](https://github.com/JuliaLinearAlgebra/AlgebraicMultigrid.jl)
to add a preconditioner to the GMRES solver.

### Part 7: Exploring IMEX and Exponential Integrator Techniques

Instead of using the standard `ODEProblem`, define a [`SplitODEProblem`](http://docs.juliadiffeq.org/latest/types/split_ode_types.html)
to move some of the equation to the the "non-stiff part". Try different splits
and solve with `KenCarp4` to see if the solution can be accelerated.

Next, use `DiffEqArrayOperator` to define part of the equation as linear, and
use the `ETDRK4` exponential integrator to solve the equation. Note that this
technique is not appropriate for this equation since it relies on the
nonlinear term being non-stiff for best results.

### Part 8: Work-Precision Diagrams for Benchmarking Solver Choices

Use the `WorkPrecisionSet` method from
[DiffEqDevTools.jl](https://github.com/JuliaDiffEq/DiffEqDevTools.jl) to
benchmark multiple different solver methods and find out what combination is
most efficient.
[Take a look at DiffEqBenchmarks.jl](https://github.com/JuliaDiffEq/DiffEqBenchmarks.jl)
for usage examples.

### Part 9: GPU-Parallelism for PDEs

Fully vectorize your implementation of the ODE and use a `CuArray` from
[CuArrays.jl](https://github.com/JuliaGPU/CuArrays.jl) as the initial condition
to cause the whole solution to be GPU accelerated.

## (I) Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles

### (B) Part 1: Implementing the Henon-Heiles System

### (B) (Optional) Part 2: Alternative Dynamical Implmentations of Henon-Heiles

### Part 3: Global Sensitivity Analysis with the Morris and Sobol Methods

### Part 4: GPU-based Ensemble Solving

### Part 5: Global Surrogate Optimization with Surrogates.jl

## (I) Training Neural Stochastic Differential Equations with GPU acceleration

### Part 1: Constructing and Training a Basic Neural ODE

### Part 2: Constructing a Basic Neural SDE

### (E) Part 3: Optimizing the training behavior with minibatching
