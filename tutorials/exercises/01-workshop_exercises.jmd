---
title: DifferentialEquations.jl Workshop Exercises
author: Chris Rackauckas
---

These excersies teach common workflows which involve DifferentialEquations.jl.
The designation (B) is for "Beginner", meaning that a user new to the package
should feel comfortable trying this exercise. An exercise designated (I) is
for "Intermediate", meaning the user may want to have some previous background
in DifferentialEquations.jl or try some (B) exercises first. The additional
(E) designation is for "Experienced", which are portions of exercises which may
take some work.

## (B) Investigating Sources of Randomness and Uncertainty in a Biological System

### Part 1: Simulating a deterministic chemical reaction system

### Part 2: Adding stochasticity with stochastic differential equations

### Part 3: Gillespie jump models of discrete stochasticity

### Part 4: Using DiffEqBiological's Reaction Network DSL

### (I) Part 5: Bayesian Parameter Estimation with DiffEqBayes.jl + Turing.jl

## (B) Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses

### Part 1: Defining an ODE with Predetermined Doses

### Part 2: Adding Delays

### Part 3: Utilizing Adjoints and Automatic Differentiation (AD) for Optimization

### Part 4: Fitting Known Quantities with DiffEqParamEstim.jl + Optim.jl

### (I) Part 5: Implementing Control-Based Logic with ContinuousCallbacks

## (B) Differential-Algebraic Equation Modeling of a Double Pendulum

Differential-Algebraic Equaton (DAE) systems are like ODEs but allow for adding
constraints into the models. This problem will look at solving the double
penulum problem with enforcement of the rigid body constraints, requiring that
the total distance `L` is constant throughout the simulation. While these
equations can be rewritten in an ODE form, in many cases it can be simpler
to solve the equation directly with the constraints. This tutorial will
cover both the idea of index, how to manually perform index reduction,
and how to make use of mass matrix and implicit ODE solvers to handle these
problems.

### Part 1: Simple Introduction to DAEs: Mass-Matrix Robertson Equations

### Part 2: Solving the Implicit Robertson Equations with IDA

### Part 3: Manual Index Reduction of the Double Pendulum

### Part 4: Double Pendulum Solution with IDA

## (I) Performance Optimizing and Parallelizing Semilinear PDE Solvers

This problem will focus on implementing and optimizing the solution of the
2-dimensional Brusselator equations. The BRUSS equations are a well-known
highly stiff oscillatory system of partial differential equations which are
used in stiff ODE solver benchmarks. In this tutorial we will walk first
through a simple implmentation, then do allocation-free implementations and
looking deep into solver options and benchmarking.

### (B) Part 1: Implementing the BRUSS PDE System as ODEs

### Part 2: Optimizing the BRUSS Code

### Part 3: Exploiting Jacobian Sparsity with Color Differentiation

### Part 4: Utilizing Preconditioned-GMRES Linear Solvers

### Part 5: Exploring IMEX and Exponential Integrator Techniques

### Part 6: Work-Precision Diagrams for Benchmarking Solver Choices

### (E) Part 7: GPU-Parallelism for PDEs

## (I) Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles

### (B) Part 1: Implementing the Henon-Heiles System

### (B) (Optional) Part 2: Alternative Dynamical Implmentations of Henon-Heiles

### Part 3: Global Sensitivity Analysis with the Morris and Sobol Methods

### Part 4: GPU-based Ensemble Solving

### Part 5: Global Surrogate Optimization with Surrogates.jl

## (I) Training Neural Stochastic Differential Equations with GPU acceleration

### Part 1: Constructing and Training a Basic Neural ODE

### Part 2: Constructing a Basic Neural SDE

### (E) Part 3: Optimizing the training behavior with minibatching
